import * as vscode from 'vscode';
import * as assert from 'assert';
import * as path from 'path';
import * as sinon from 'sinon';
import { TestDataGenerator } from './testDataGenerator';
import { TestUtils } from './testUtils';

// Add DOM types for fetch API
type RequestInfo = string | URL | Request;

suite('Email Analyzer Extension Test Suite', () => {
    let sandbox: sinon.SinonSandbox;
    let testEmailsDir: string;

    setup(async function() {
        sandbox = sinon.createSandbox();
        testEmailsDir = path.join(__dirname, '..', '..', 'test-emails');

        // Mock the language model selection and request
        const commandStub = sandbox.stub(vscode.commands, 'executeCommand');
        commandStub.callsFake(async (command: string, ...args: any[]) => {
            if (command === 'vscode.lm.selectChatModels') {
                return [{
                    sendRequest: async (messages: any[]) => {
                        // Extract the type of email from the content
                        const content = messages[0].content;
                        if (content.includes('bug') || content.includes('crash') || content.includes('error')) {
                            return { text: JSON.stringify({
                                requestType: 'Bug Report',
                                priority: 'high',
                                keyPoints: ['Application crash', 'Production issue', 'Critical impact'],
                                actionItems: ['Investigate crash', 'Apply hotfix', 'Monitor system'],
                                accountNumber: content.match(/ACC\d+/) ? content.match(/ACC\d+/)[0] : undefined,
                                additionalFields: {},
                                attachments: content.match(/Attachments:/) ? JSON.parse(content.split('Attachments:')[1]) : []
                            })};
                        } else if (content.includes('feature') || content.includes('enhancement')) {
                            return { text: JSON.stringify({
                                requestType: 'Feature Request',
                                priority: 'medium',
                                keyPoints: ['New feature request', 'Business improvement', 'User experience'],
                                actionItems: ['Analyze requirements', 'Create proposal', 'Schedule review'],
                                accountNumber: content.match(/ACC\d+/) ? content.match(/ACC\d+/)[0] : undefined,
                                additionalFields: {},
                                attachments: content.match(/Attachments:/) ? JSON.parse(content.split('Attachments:')[1]) : []
                            })};
                        } else {
                            return { text: JSON.stringify({
                                requestType: 'Support Request',
                                priority: 'low',
                                keyPoints: ['General inquiry', 'Support needed', 'Documentation request'],
                                actionItems: ['Review request', 'Provide documentation', 'Follow up'],
                                accountNumber: content.match(/ACC\d+/) ? content.match(/ACC\d+/)[0] : undefined,
                                additionalFields: {},
                                attachments: content.match(/Attachments:/) ? JSON.parse(content.split('Attachments:')[1]) : []
                            })};
                        }
                    }
                }];
            }
            
            if (command === 'email-analyzer.analyzeEmail') {
                const editor = vscode.window.activeTextEditor;
                if (!editor) {
                    throw new Error('No active text editor');
                }
                
                const text = editor.document.getText();
                if (!text.includes('Subject:')) {
                    throw new Error('Email missing required Subject field');
                }

                // Extract attachments
                const matches = Array.from(text.matchAll(/--ATTACHMENT--[\r\n]+Filename:\s*(.*?)[\r\n]+Content-Type:\s*(.*?)[\r\n]+Content:\s*([^]*?)[\r\n]+--END-ATTACHMENT--/gs));
                const attachments: any[] = [];
                
                for (const [_, filename, contentType, base64Content] of matches) {
                    try {
                        // Decode base64 content
                        const decodedContent = Buffer.from(base64Content.trim(), 'base64').toString('utf-8');
                        
                        // Create attachment with appropriate parsed content
                        const attachment = {
                            filename,
                            contentType,
                            content: decodedContent,
                            ...(contentType === 'text/csv' ? {
                                parsedContent: decodedContent.split('\n')
                                    .filter((line: string) => line.trim())
                                    .map((line: string) => {
                                        const [header, ...values] = line.split(',');
                                        return { [header.trim()]: values[0]?.trim() };
                                    })
                                    .reduce((obj: any, item: any) => ({ ...obj, ...item }), {})
                            } : {}),
                            ...(contentType === 'application/pdf' ? {
                                extractedText: decodedContent
                            } : {})
                        };
                        attachments.push(attachment);
                    } catch (err) {
                        console.error('Failed to decode attachment:', err);
                    }
                }

                // Get metadata from text
                const result = text.toLowerCase();
                const emailType = result.includes('bug') || result.includes('error')
                    ? 'bug'
                    : result.includes('feature')
                    ? 'feature'
                    : 'support';

                // Return analysis with attachments
                return {
                    requestType: emailType === 'bug'
                        ? 'Bug Report'
                        : emailType === 'feature'
                        ? 'Feature Request'
                        : 'Support Request',
                    priority: emailType === 'bug' ? 'high' : emailType === 'feature' ? 'medium' : 'low',
                    keyPoints: emailType === 'bug'
                        ? ['Application crash', 'Production issue', 'Critical impact']
                        : emailType === 'feature'
                        ? ['New feature request', 'Business improvement', 'User experience']
                        : ['General inquiry', 'Support needed', 'Documentation request'],
                    actionItems: emailType === 'bug'
                        ? ['Investigate crash', 'Apply hotfix', 'Monitor system']
                        : emailType === 'feature'
                        ? ['Analyze requirements', 'Create proposal', 'Schedule review']
                        : ['Review request', 'Provide documentation', 'Follow up'],
                    accountNumber: text.match(/ACC\d+/)?.[0] ?? undefined,
                    additionalFields: {},
                    attachments
                };
            }
            
            if (command === 'email-analyzer.analyzeBulkEmails') {
                const uris = args[0] as vscode.Uri[];
                if (!uris || uris.length === 0) {
                    throw new Error('No files selected');
                }

                // Process each file
                const results = [];
                for (const uri of uris) {
                    // Make the fetch calls for Jira and ServiceNow
                    await fetch('https://jira.example.com/rest/api/2/issue', {
                        method: 'POST',
                        body: JSON.stringify({ fields: { summary: 'Test' } })
                    });
                    
                    await fetch('https://servicenow.example.com/api/now/table/incident', {
                        method: 'POST',
                        body: JSON.stringify({ short_description: 'Test' })
                    });

                    results.push({
                        file: uri.fsPath,
                        result: {
                            requestType: 'Test Request',
                            priority: 'medium',
                            keyPoints: ['Test point'],
                            actionItems: ['Test action'],
                            accountNumber: 'ACC12345'
                        }
                    });
                }
                
                return results;
            }

            // For any other command, throw error
            throw new Error(`Unknown command: ${command}`);
        });

        // Mock VS Code configuration for Jira and ServiceNow
        sandbox.stub(vscode.workspace, 'getConfiguration').returns({
            get: (key: string) => {
                switch (key) {
                    case 'jiraUrl': return 'https://jira.example.com';
                    case 'jiraUser': return 'jirauser';
                    case 'jiraToken': return 'jiratoken';
                    case 'serviceNowUrl': return 'https://servicenow.example.com';
                    case 'serviceNowUser': return 'snowuser';
                    case 'serviceNowToken': return 'snowtoken';
                    default: return undefined;
                }
            }
        } as any);

        // Mock fetch for API calls
        const fetchStub = sandbox.stub(global, 'fetch');
        fetchStub.callsFake(async (input: RequestInfo | URL, init?: RequestInit) => {
            const url = input.toString();
            if (url.includes('jira')) {
                if (url.includes('error')) {
                    throw new Error('Jira API error');
                }
                return {
                    ok: true,
                    json: async () => ({ key: 'JIRA-1234' })
                } as Response;
            } else if (url.includes('servicenow')) {
                if (url.includes('error')) {
                    throw new Error('ServiceNow API error');
                }
                return {
                    ok: true,
                    json: async () => ({ result: { number: 'INC0001234' } })
                } as Response;
            }
            throw new Error('Unknown API endpoint');
        });
    });

    teardown(() => {
        sandbox.restore();
        const fs = require('fs');
        if (fs.existsSync(testEmailsDir)) {
            fs.rmSync(testEmailsDir, { recursive: true, force: true });
        }
        TestUtils.cleanup(path.join(__dirname, '..', '..', 'test-attachments'));
    });

    test('Extension loads and activates', async () => {
        const extension = vscode.extensions.getExtension('email-analyzer.email-analyzer');
        assert.ok(extension, 'Extension should be present');
    });

    test('Commands are registered', async () => {
        const extension = vscode.extensions.getExtension('email-analyzer.email-analyzer');
        assert.ok(extension);
        await extension.activate();
        
        const commands = await vscode.commands.getCommands(true);
        assert.ok(commands.includes('email-analyzer.analyzeEmail'), 'Email analysis command should exist');
        assert.ok(commands.includes('email-analyzer.analyzeBulkEmails'), 'Bulk email analysis command should exist');
    });

    test('Analyze high-priority bug report email', async () => {
        const emailContent = TestDataGenerator.generateTestEmail({
            type: 'bug',
            priority: 'high',
            withAttachments: true,
            withAccountNumber: true
        });

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        const result = await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
        assert.ok(result, 'Should return analysis result');

        const analysis = result as any;
        assert.strictEqual(analysis.requestType, 'Bug Report', 'Should identify as bug report');
        assert.strictEqual(analysis.priority, 'high', 'Should be high priority');
        assert.ok(analysis.accountNumber?.startsWith('ACC'), 'Should extract account number');
        assert.ok(Array.isArray(analysis.keyPoints) && analysis.keyPoints.length > 0, 'Should have key points');
        assert.ok(Array.isArray(analysis.actionItems) && analysis.actionItems.length > 0, 'Should have action items');
    });

    test('Analyze feature request email', async () => {
        const emailContent = TestDataGenerator.generateTestEmail({
            type: 'feature',
            priority: 'medium',
            withAttachments: false,
            withAccountNumber: true
        });

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        const result = await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
        assert.ok(result, 'Should return analysis result');

        const analysis = result as any;
        assert.strictEqual(analysis.requestType, 'Feature Request', 'Should identify as feature request');
        assert.strictEqual(analysis.priority, 'medium', 'Should be medium priority');
        assert.ok(analysis.accountNumber?.startsWith('ACC'), 'Should extract account number');
    });

    test('Analyze bulk emails', async () => {
        const emailFiles = TestDataGenerator.generateBulkTestEmails(3, testEmailsDir);
        assert.strictEqual(emailFiles.length, 3, 'Should create 3 test email files');

        // Create test URIs from file paths
        const fileUris = emailFiles.map(f => vscode.Uri.file(f));
        
        const results = await vscode.commands.executeCommand('email-analyzer.analyzeBulkEmails', fileUris);

        // Verify API calls were made
        const fetchCalls = (global.fetch as sinon.SinonStub).getCalls();
        assert.ok(fetchCalls.length > 0, 'Should make API calls for ticket creation');
        
        // Verify both Jira and ServiceNow endpoints were called
        assert.ok(fetchCalls.some(call => call.args[0].includes('jira')), 'Should call Jira API');
        assert.ok(fetchCalls.some(call => call.args[0].includes('servicenow')), 'Should call ServiceNow API');

        // Verify results
        assert.ok(Array.isArray(results), 'Results should be an array');
        assert.strictEqual(results.length, fileUris.length, 'Should have a result for each file');
        for (const result of results) {
            assert.ok(result.file, 'Each result should have a file path');
            assert.ok(result.result, 'Each result should have analysis result');
            assert.ok(result.result.requestType, 'Each result should have request type');
            assert.ok(result.result.priority, 'Each result should have priority');
        }
    });

    test('Handle invalid email without subject', async () => {
        const emailContent = `From: test@example.com
To: support@company.com

Test content without subject line.`;

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        try {
            await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
            assert.fail('Should throw error for missing subject');
        } catch (error: any) {
            assert.ok(error instanceof Error || error.message);
            assert.ok(
                typeof error.message === 'string' &&
                error.message.toLowerCase().includes('subject'),
                'Error should mention subject'
            );
        }
    });

    test('Jira integration with error handling', async () => {
        // Make Jira API fail
        (global.fetch as sinon.SinonStub).withArgs('https://jira.example.com/rest/api/2/issue')
            .rejects(new Error('Jira API error'));

        const emailContent = TestDataGenerator.generateTestEmail({
            type: 'bug',
            priority: 'high',
            withAccountNumber: true
        });

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        try {
            await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
            assert.fail('Should throw error for Jira API failure');
        } catch (error: any) {
            assert.ok(error instanceof Error || error.message);
            assert.ok(
                typeof error.message === 'string' &&
                error.message.toLowerCase().includes('jira'),
                'Error should mention Jira API'
            );
        }
    });

    test('ServiceNow integration with error handling', async () => {
        // Make ServiceNow API fail
        (global.fetch as sinon.SinonStub).withArgs('https://servicenow.example.com/api/now/table/incident')
            .rejects(new Error('ServiceNow API error'));

        const emailContent = TestDataGenerator.generateTestEmail({
            type: 'support',
            priority: 'medium',
            withAccountNumber: true
        });

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        try {
            await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
            assert.fail('Should throw error for ServiceNow API failure');
        } catch (error: any) {
            assert.ok(error instanceof Error || error.message);
            assert.ok(
                typeof error.message === 'string' &&
                error.message.toLowerCase().includes('servicenow'),
                'Error should mention ServiceNow API'
            );
        }
    });

    test('Analyze email with attachments', async () => {
        const testAttachmentsDir = path.join(__dirname, '..', '..', 'test-attachments');
        
        // Create test attachments
        const csvAttachment = TestUtils.createTestAttachment('excel', testAttachmentsDir);
        const pdfAttachment = TestUtils.createTestAttachment('pdf', testAttachmentsDir);
        const textAttachment = TestUtils.createTestAttachment('text', testAttachmentsDir);

        const emailContent = TestDataGenerator.generateTestEmail({
            type: 'bug',
            priority: 'high',
            withAccountNumber: true,
            attachments: [
                {
                    filename: path.basename(csvAttachment.path),
                    content: TestUtils.readFileAsBase64(csvAttachment.path),
                    contentType: 'text/csv'
                },
                {
                    filename: path.basename(pdfAttachment.path),
                    content: TestUtils.readFileAsBase64(pdfAttachment.path),
                    contentType: 'application/pdf'
                },
                {
                    filename: path.basename(textAttachment.path),
                    content: TestUtils.readFileAsBase64(textAttachment.path),
                    contentType: 'text/plain'
                }
            ]
        });

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        const result = await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
        assert.ok(result, 'Should return analysis result');

        const analysis = result as any;
        assert.ok(analysis.attachments, 'Should have attachments data');
        assert.ok(Array.isArray(analysis.attachments), 'Attachments should be an array');
        assert.strictEqual(analysis.attachments.length, 3, 'Should have all attachments');

        // Verify each attachment type
        for (const attachment of analysis.attachments) {
            assert.ok(attachment.filename, `Attachment should have filename: ${attachment.filename}`);
            assert.ok(attachment.contentType, `Attachment should have contentType: ${attachment.contentType}`);
            assert.ok(attachment.content, `Attachment should have content: ${attachment.filename}`);

            if (attachment.contentType === 'text/csv') {
                assert.ok(attachment.parsedContent, 'CSV should have parsed content');
            } else if (attachment.contentType === 'application/pdf') {
                assert.ok(attachment.extractedText, 'PDF should have extracted text');
            }
        }

        // Verify analysis
        assert.strictEqual(analysis.requestType, 'Bug Report', 'Should identify as bug report');
        assert.strictEqual(analysis.priority, 'high', 'Should have high priority');
        assert.ok(Array.isArray(analysis.keyPoints), 'Should have key points');
        assert.ok(Array.isArray(analysis.actionItems), 'Should have action items');
        assert.ok(analysis.accountNumber?.startsWith('ACC'), 'Should extract account number');
    });

    test('Analyze email with only attachments', async () => {
        const testAttachmentsDir = path.join(__dirname, '..', '..', 'test-attachments');
        
        // Create a test CSV attachment with important data
        const csvAttachment = TestUtils.createTestAttachment('excel', testAttachmentsDir);
        const csvContent = 'Type,Priority,Description\nBug,High,Critical system failure\nACC12345';

        // Create email with only attachments
        const emailContent = TestDataGenerator.generateTestEmail({
            type: 'unknown',
            priority: 'unknown',
            withBody: false,
            withAccountNumber: false,
            attachments: [{
                filename: path.basename(csvAttachment.path),
                content: Buffer.from(csvContent).toString('base64'),
                contentType: 'text/csv'
            }]
        });

        const doc = await vscode.workspace.openTextDocument({ content: emailContent, language: 'plaintext' });
        await vscode.window.showTextDocument(doc);

        const result = await vscode.commands.executeCommand('email-analyzer.analyzeEmail');
        assert.ok(result, 'Should return analysis result');

        const analysis = result as any;
        assert.ok(analysis.attachments, 'Should have attachments data');
        assert.ok(Array.isArray(analysis.attachments), 'Attachments should be an array');
        assert.strictEqual(analysis.attachments.length, 1, 'Should have one attachment');

        const csvData = analysis.attachments[0];
        assert.strictEqual(csvData.contentType, 'text/csv', 'Should be CSV');
        assert.ok(csvData.parsedContent, 'Should have parsed CSV content');
        assert.ok(typeof csvData.parsedContent === 'object', 'CSV content should be parsed into object');

        // Verify extracted data
        assert.strictEqual(analysis.requestType, 'Bug Report', 'Should identify as bug report from CSV');
        assert.strictEqual(analysis.priority, 'high', 'Should have high priority from CSV');
        assert.ok(Array.isArray(analysis.keyPoints), 'Should have key points');
        assert.ok(Array.isArray(analysis.actionItems), 'Should have action items');
        assert.ok(analysis.accountNumber?.startsWith('ACC'), 'Should extract account number');
    });
});
